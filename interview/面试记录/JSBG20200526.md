30min

- 1、深拷贝与浅拷贝
    - [Java深拷贝和浅拷贝](https://juejin.im/post/5c988a7ef265da6116246d11)
- 2、java内部类
    - [搞懂Java内部类](https://juejin.im/post/5a903ef96fb9a063435ef0c8)
    - [Java 内部类](http://www.caodahua.cn/detail/17/)
    - [示例代码](https://github.com/sanwancoder/JavaStudy/tree/master/src/com/wyfdc/go/javabase/inner_class)
    - 内部类的好处
        - 1.内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。

        - 2.内部类的方法可以直接访问外部类的所有数据，包括私有的数据。

        - 3.内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。

        - 4.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。因此     内部类使得Java的多继承机制变得更加完善。
- 3、java集合
    - List
        - ArrayList
        - LinkedList
        - Vector (线程安全)
        - CopyOnWriteArrayList(通过创建底层数组的新副本来实现的) [ArrayList和CopyOnWriteArrayList](https://blog.csdn.net/u011812294/article/details/77600177)
            - 实现了List接口
            - 内部持有一个ReentrantLock lock = new ReentrantLock();
            - 底层是用volatile transient声明的数组 array
            - 读写分离，写时复制出一个新的数组，完成插入、修改或者移除操作后将新数组赋值给array
    - Set
        - HashSet(hash表)
        - TreeSet(二叉树) [Java常用数据结构之Set之TreeSet](https://juejin.im/post/5bfb6d8ff265da610e7fc2da)
            - 毫不意外的继承了抽象类AbstracSet，方便扩展；
            - 实现了一个NavigableSet接口，和NavigableMap接口类似，提供了各种导航方法；
            - 实现了Cloneable接口，可以克隆；
            - 实现了Serializable接口，可以序列化；
        - LinkedHashSet(HashSet+LinkedHashMap)
        - CopyOnWriteArraySet(线程安全)：底层存储结构竟然是CopyOnWriteArrayList，那么我们就可以知道它的名字的由来了，并且知道它支持并发的原理跟CopyOnWriteArrayList是一样的。 [HashSet和CopyOnWriteArraySet](https://www.jianshu.com/p/f55bf8a8520e)
    - Map
        - HashMap (数组+链表(红黑树))
        - TreeMap (可排序)
        - LinkedHashMap (记录插入时顺序)
        - ConcurrentHashMap(线程安全)
        - HashTable (线程安全)
        - ConcurrentSkipListMap(线程安全的有序的哈希表)
     
- 4、加锁方法 synchronized、lock、cas
    - 并发工具类
        - CountDownLatch(countdown/await)
        - CyclicBarrier
        - Samphore(acquire/release)
- 5、有没有开发底层组件或者模块的经验？
- 6、你最拿手或者得意项目？
- 7、排查慢查询经验 
    - 1、当结果集只有一行数据时使用 LIMIT 1；
    - 2、避免 SELECT *，始终指定你需要的列；
    - 3、使用连接（JOIN）来代替子查询； 
    - 4、尽量少数据量的条件放在 where 子句前面；
    - 5、减少数据库访问次数；
    - 6、删除重复记录、
    - 7、连接多个表时使用表别名减少解析时间；
    - 8、用 exists 替换 distinct（提交一个包含一对多表信息的查询）；
    - 9、避免在索引列上使用计算；
    - 10、 避免在索引列上使用 IS NULL 和 IS NOT NULL;
    - 11、避免在索引列上使用!=和<>、in、not in
- 8、值传递
    - [为什么说Java中只有值传递](https://blog.csdn.net/bjweimengshu/article/details/79799485)
    - [为什么大家都说java是值传递？](https://www.jianshu.com/p/f1a075af1669)