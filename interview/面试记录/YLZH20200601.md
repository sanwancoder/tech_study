40min

- 1、接口和抽象类区别
	- 区别
		- 1).抽象类是单一继承（子类只能有一个父类，继承抽象类表示“从属”），接口是多重实现（子类可以实现多个接口，实现接口表示“组合”关系）
		- 2).接口中全是抽象方法；抽象类中可以有抽象方法，也可有方法体的方法
		- 3).接口中无构造方法，不可继承，可实现；抽象类可有构造方法，不可被实例化
		- 4).抽象类的抽象方法不能使用 private，final，static，方法不能用 private，final 修饰；接口的属性默认是用public，static，final 修饰，接口中方法是默认用 public，abstract 修饰
	- java访问修饰符有哪些？
		 - default(包可见)
		 - private
		 - protected
		 - public
	- 抽象类默认访问修饰符是什么？
- 2、用到哪些 SpringCloud 组件？ [Spring Cloud集成相关优质项目推荐](https://www.springcloud.cc/)
	- ribbon
	- feign
	- zuul
		- 网关有什么作用？
			- 1、提供统一服务入口，微服务对前台透明
			- 2、聚合后台服务，节省流量，提升性能
			- 3、安全，过滤，流控等API管理功能
			- 4、提供统一服务出口，解耦
	- starters
	- eureka/zookeeper/consul/[nacos](https://nacos.io/zh-cn/)
	- spring cloud config/[apollo](https://github.com/ctripcorp/apollo)/[disconf](https://github.com/knightliao/disconf)/[nacos](https://nacos.io/zh-cn/)
	- zipkin+sleuth(链路跟踪)
	- hystrix
	 
- 3、HashTable和 ConcurrentHashMap 区别？(面试官直接不问HashMap相关问题)
- 4、垃圾回收器CMS和G1比较
	- CMS(**多线程标记-清除算法**)
		- 分为四个阶段：初始标记 --> 并发标记 -->	重新标记 --> 并发清除
	- G1(Garbage First) 
		- 基于**标记-整理**算法，不会产生内存碎片
		- 可以非常精准控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿垃圾回收
		- G1 收集器**避免全区域垃圾收集**，它把**堆内存划分为大小固定的几个独立区域**，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。
- 5、乐观锁和悲观锁比较
- 6、常见的排序算法比较
	- 快排(分而治之思想)
	- 归并排序
	- 冒泡排序
	- 选择排序
	- 桶排序(基数排序)
	- 堆排序